{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"New coursier website","text":"<p>This website is in construction. See the legacy website for details about other topics.</p>"},{"location":"api-dependency/","title":"Dependency","text":"<p>One can specify input dependencies of a resolution via the <code>Dependency</code> class, like <pre><code>val module = Module(Organization(\"my-org\"), ModuleName(\"my-name\"), Map.empty)\nval versionConstraint = VersionConstraint(\"1.2.3\")\nDependency(module, versionConstraint)\n</code></pre></p> <p>In Scala 2.x, string interpolators allow to specify dependencies using the same syntax than on the CLI: <pre><code>dep\"my-org:my-name:1.2.3\"\n</code></pre></p>"},{"location":"api-dependency/#bill-of-material","title":"Bill Of Material","text":"<p>Bills Of Material, or BOMs, allow to:</p> <ul> <li>fill input dependencies' versions if these are empty</li> <li>override versions of transitive dependencies</li> </ul> <p>To pass a BOM to a dependency, you can call <code>addBom</code> on a <code>Dependency</code>: <pre><code>val module = Module(Organization(\"my-org\"), ModuleName(\"my-name\"), Map.empty)\nval versionConstraint = VersionConstraint(\"1.2.3\")\nval bomModule = Module(Organization(\"my-org\"), ModuleName(\"my-bom\"), Map.empty)\nval bomVersionConstraint = VersionConstraint(\"1.0.1\")\nDependency(module, versionConstraint)\n  .addBom(BomDependency(bomModule, bomVersionConstraint))\n</code></pre>  In Scala 2.x, on can use convenient string interpolators: <pre><code>dep\"my-org:my-name:1.2.3\"\n  .addBom(mod\"my-org:my-bom\", bomVersionConstraint)\n</code></pre> or <pre><code>dep\"my-org:my-name:1.2.3\"\n  .addBom(dep\"my-org:my-bom:1.0.1\".asBomDependency)\n</code></pre></p>"},{"location":"api-dependency/#gradle-module-variant","title":"Gradle Module Variant","text":""},{"location":"api-dependency/#adding-attributes-to-a-dependency","title":"Adding attributes to a dependency","text":"<p>One can ask for specific Gradle Module variants of a dependency, like <pre><code>dep\"my-org:my-name:1.2.3\".addVariantAttributes(\n  \"org.gradle.usage\" -&gt; \"kotlin-runtime\",\n  \"org.jetbrains.kotlin.platform.type\" -&gt; \"js\",\n  \"org.jetbrains.kotlin.js.compiler\" -&gt; \"ir\",\n  \"org.gradle.category\" -&gt; \"library\"\n)\n</code></pre></p> <p>Note that calling <code>Dependency#addVariantAttributes</code> discards any configuration details the dependency might have previously in its <code>variantSelector</code> field (see below).</p>"},{"location":"api-dependency/#gradle-module-variants-versus-maven-configuration","title":"Gradle Module Variants versus Maven Configuration","text":"<p>A <code>Dependency</code> instance can ask either for a Maven Configuration, or for Gradle Module variants. By default, <code>Dependency</code> instances ask for the empty configuration, which is interpreted internally as no configuration nor variants. During resolution, that empty configuration gets substituted by the default configuration pulled by the resolution (whose value is the <code>default(runtime)</code> configuration, meaning if direct dependencies have a configuration named <code>default</code>, it gets pulled - else, the configuration named <code>runtime</code> gets pulled).</p> <p>The dependency field handling both Gradle Module Variants and Maven Configurations is <code>Dependency#variantSelector</code>, whose type is <code>coursier.core.VariantSelector</code>: <pre><code>dep\"my-org:my-name:1.2.3\".variantSelector\n// res9: VariantSelector = ConfigurationBased(\n//   configuration = Configuration(value = \"\")\n// )\n</code></pre></p> <p><code>VariantSelector</code> is an ADT, and has 2 cases:</p> <ul> <li><code>VariantSelector.ConfigurationBased</code>, that corresponds to Maven Configurations</li> <li><code>VariantSelector.AttributesBased</code>, that corresponds to Gradle Module Variants</li> </ul>"},{"location":"api-dependency/#maven-configuration-fallback","title":"Maven Configuration fallback","text":"<p>coursier tries to download Gradle Module files if and only if dependencies are attributes-based, that is ask for specific Gradle Module variants.</p> <p>If a repository doesn't have a Gradle Module file for such dependency, but has a POM file for it, coursier falls back to using Maven Configurations for this module. The configuration it falls back to is computed by the <code>VariantSelector.AttributesBased#equivalentConfiguration</code> method.</p> <p>As of writing this, it does the following:</p> <ul> <li>if the dependency has an <code>org.gradle.usage</code> attribute whose value is <code>java-api</code> or <code>kotlin-api</code>, it falls back to the <code>compile</code> Maven Configuration</li> <li>if the dependency has an <code>org.gradle.usage</code> attribute whose value is <code>java-runtime</code> or <code>kotlin-runtime</code>, it falls back to the <code>runtime</code> Maven Configuration</li> </ul> <p>If none of those conditions are met, during resolution, coursier falls back to the default configuration of the resolution (whose default value is <code>default(runtime)</code>).</p>"},{"location":"api/","title":"API","text":"<p>Coursier can be used as a Scala library. Its main dependency is <pre><code>io.get-coursier::coursier:2.1.25-M1-59-6c015ed62-SNAPSHOT\n</code></pre></p> <p>The pages that follow document how to use coursier via these libraries.</p> <p>Most pages assume that the content of the <code>coursier</code> package has been imported, like <pre><code>import coursier._\n</code></pre></p>"},{"location":"cli-dependency/","title":"Dependency","text":""},{"location":"cli-dependency/#syntax","title":"Syntax","text":"<pre><code>org:name:version\n</code></pre>"},{"location":"cli-dependency/#bill-of-material","title":"Bill Of Material","text":"<p>One can pass a Bill-Of-Material, or BOM, via dependencies, like <pre><code>com.google.protobuf:protobuf-java-util,bom=com.google.protobuf%protobuf-bom%4.28.1\n</code></pre></p> <p>Note the use of <code>%</code> rather than <code>:</code> to separate the components of the BOM coordinates.</p>"},{"location":"cli-dependency/#gradle-module-variant","title":"Gradle Module Variant","text":"<p>One can add Gradle Module attributes to a dependency, so that it checks if a Gradle Module file exists for that dependency, and uses it to pick a \"variant\" of that dependency: <pre><code>org.jetbrains.kotlinx:kotlinx-html-js:0.11.0,variant.org.gradle.usage=kotlin-runtime,variant.org.jetbrains.kotlin.platform.type=js,variant.org.jetbrains.kotlin.js.compiler=ir,variant.org.gradle.category=library\n</code></pre></p> <p>If we split / indent that dependency for readability, we get <pre><code>org.jetbrains.kotlinx:kotlinx-html-js:0.11.0,\n  variant.org.gradle.usage=kotlin-runtime,\n  variant.org.jetbrains.kotlin.platform.type=js,\n  variant.org.jetbrains.kotlin.js.compiler=ir,\n  variant.org.gradle.category=library\n</code></pre></p> <p>Gradle Module attributes are key-value pairs. These are added as parameters to dependencies. <code>variant.</code> is added as prefix to the key of the attribute, and the parameter value is the attribute value.</p>"},{"location":"cli/","title":"CLI","text":"<p>Coursier can be used via its CLI. Its CLI is distributed as a native binary, and as a JAR that needs an already installed JVM to run.</p>"},{"location":"features-bom/","title":"Bill Of Material","text":"<p>Bills Of Material, or BOMs, allow to:</p> <ul> <li>fill input dependencies' versions if these are empty</li> <li>override versions of transitive dependencies</li> </ul> <p>See the dedicated API section and the dedicated CLI section.</p>"},{"location":"features-gradle-modules/","title":"Gradle Modules support","text":"<p>coursier has some support for Gradle Modules.</p> <p>Gradle Module files are <code>.module</code> files that are pused alongside <code>.pom</code> files to Maven repositories by some Gradle projects. These contain richer metadata that POM files, allowing users to specify different dependency sets and artifacts depending on the platform being used (JVM, Android, native, \u2026), in particular.</p> <p>For example, this dependency publishes a <code>.module</code> file alongside its POM file. Such files are especially used in the Android and Kotlin ecosystems.</p> <p>Coursier is able to read and take into account <code>.module</code> files. One has to add variant attributes to dependencies for coursier to do so. See how that can be done via the API and via the CLI.</p>"},{"location":"features/","title":"Coursier features","text":"<p>These pages are deep dives into various features of coursier. They sometimes link to sections of the API or CLI documentations for more details.</p>"}]}