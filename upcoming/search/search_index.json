{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"New coursier website","text":"<p>This website is in construction. See the legacy website for details about other topics.</p>"},{"location":"#where-to-look","title":"Where to look?","text":"<p>The coursier cache backs basically all coursier features. It should be important for you to understand how it works.</p> <ul> <li>cache</li> </ul> <p>What user are you?</p>"},{"location":"#mill-user","title":"Mill user","text":"<p>You use coursier via Mill. Mill uses coursier to get and manage JVM dependencies. It also uses it to fetch JVMs, if you're using the Mill native launcher, or Mill's per module JVM capabilities.</p> <ul> <li>archive cache</li> <li>JVM</li> <li>Gradle Modules</li> <li>BOM</li> <li>dependency format</li> </ul>"},{"location":"#scala-user","title":"Scala user","text":"<p>You use the coursier CLI to setup Scala on your machine, following the instructions of the scala-lang.org website.</p> <ul> <li>setup</li> <li>install</li> <li>bootstraps</li> <li>JVM</li> </ul>"},{"location":"#scala-cli-user","title":"Scala CLI user","text":"<p>You use coursier via Scala CLI. Scala CLI relies on many coursier features, most notably JVM dependencies resolution and JVM management.</p> <ul> <li>dependency format</li> <li>archive cache</li> <li>JVM</li> </ul>"},{"location":"#scala-sbt-user","title":"Scala / sbt user","text":"<p>You use coursier via sbt. sbt uses coursier to get and manage JVM dependencies.</p> <ul> <li>sbt particularities (relaxed reconciliation, disabled BOM support, no Gradle Module support, \u2026)</li> </ul>"},{"location":"#bazel-user","title":"Bazel user","text":"<p>You use coursier via Bazel's rules_jvm_external. rules_jvm_external uses the coursier CLI to fetch dependencies, and uses the coursier CLI's JSON report output to read its results.</p> <ul> <li>Gradle Modules</li> <li>BOM</li> <li>dependency format</li> <li>report</li> </ul>"},{"location":"#jvm-user","title":"JVM user","text":"<p>You use the coursier CLI to manage JVMs on your machine or from scripts.</p> <ul> <li>archive cache</li> <li>JVM</li> </ul>"},{"location":"#java-user","title":"Java user","text":"<p>You use the coursier Java API to download dependencies, and maybe JVMs or archives too.</p> <ul> <li>Java API</li> <li>archive cache</li> <li>JVM</li> </ul>"},{"location":"#docker-user","title":"Docker user","text":"<p>You use the coursier CLI to fetch, run, and maybe build Docker images.</p> <ul> <li>archive cache</li> <li>digest cache</li> <li>digest archive cache</li> <li>docker (feature, API, CLI)</li> </ul>"},{"location":"about-community/","title":"Community","text":"<ul> <li>GitHub issues (individual repos)</li> <li> <p>GitHub discussions (main coursier repo)</p> </li> <li> <p>Scala Discord (#tooling channel)</p> </li> </ul>"},{"location":"about-contact/","title":"Contact","text":"<p>As much as possible, use public channels to ask questions and report issues about coursier.</p> <p>For urgent security-related requests (especially CVEs before public disclosure), please contact both myself (Alex Archambault) and the coursier-security mailing list.</p> <p>A number of employees from the Scala Center and the VirtusLab open source team have write access to the coursier repository in case of emergency.</p>"},{"location":"about-funding/","title":"Funding","text":"<p>While coursier received contributions from more than a hundred people (most notably through code), it is developped in large part by Alex Archambault.</p> <p>While I (Alex Archambault) worked on coursier on my own time, I've also been paid along the years to work on it, by</p> <ul> <li>the Scala Center (2018-2019, then sparsely in 2020)</li> <li>VirtusLab (2021-2023, as part of my work on Scala CLI, that I'm also a main author of, albeit in a lesser extent than coursier)</li> <li>Li Haoyi (2024 - on going, while working on the Mill build tool)</li> </ul> <p>If you're interested in funding specific features of coursier, or even more generally the overall development of coursier, do not hesitate to reach me on LinkedIn, X, or via e-mail - see the links on my GitHub profile.</p>"},{"location":"about-security/","title":"Security","text":""},{"location":"about-security/#cve","title":"CVE","text":"<p>As of writing this, coursier has been indirectly impacted by two CVEs: - CVE-2022-46751 - CVE-2022-37866</p> <p>See the contact page if you need to reach coursier maintainers for urgent non-public security-related issues.</p>"},{"location":"about-security/#artifact-attestations","title":"Artifact attestations","text":"<p>coursier use the actions/attest-build-provenance GitHub action to attest that the binaries it distributes on its release pages were indeed built by the GitHub Action runners themselves. Attestations can be found here.</p>"},{"location":"api-archive-cache/","title":"Archive cache","text":""},{"location":"api-archive-cache/#example","title":"Example","text":"<p>Get the directory where an archive is extracted with <pre><code>import coursier.cache.ArchiveCache\nimport coursier.util.Artifact\nval archiveCache = ArchiveCache()\nval dir = archiveCache.get(Artifact(\"https://cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip\")).unsafeRun()(archiveCache.cache.ec) // java.io.File\n</code></pre></p>"},{"location":"api-archive-cache/#progress-bars","title":"Progress bars","text":"<p>Enable those on a standard cache, and pass it to the <code>ArchiveCache</code> to get progress bars when files are being downloaded: <pre><code>import coursier.cache.{ArchiveCache, FileCache}\nimport coursier.cache.loggers.RefreshLogger\nimport coursier.util.Artifact\nval logger = RefreshLogger.create()\nval cache = FileCache().withLogger(logger)\nval archiveCache = ArchiveCache().withCache(cache)\nval dir = logger.using(archiveCache.get(Artifact(\"https://cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip\"))).unsafeRun()(archiveCache.cache.ec) // java.io.File\n</code></pre></p> <p>Note that there's no progress reporting while the archive is being extracted for now.</p>"},{"location":"api-archive-cache/#archive-cache-location","title":"Archive cache location","text":"<p>Get the archive cache location with <pre><code>val archiveCache = ArchiveCache()\narchiveCache.location // java.io.File\n</code></pre></p> <p>Set the directory under which all archives are extracted with</p> <p>Override it with <pre><code>import java.io.File\nval archiveCache = ArchiveCache().withLocation(??? : File)\n</code></pre></p> <p>Note that this only changes the directory under which archives are extracted, not the directory where these are downloaded. To change the latter too, create a standard cache instance with a custom location, and pass it to the <code>ArchiveCache</code> with <code>withCache</code> like above.</p>"},{"location":"api-cache/","title":"Cache","text":""},{"location":"api-cache/#example","title":"Example","text":"<p>One can download files via the coursier cache with <pre><code>import coursier.cache.FileCache\nimport coursier.util.Artifact\nval cache = FileCache()\nval artifact = Artifact(\"https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.jar\")\nval file = cache.file(artifact).run.unsafeRun()(cache.ec) // java.io.File\n</code></pre></p>"},{"location":"api-cache/#progress-bars","title":"Progress bars","text":"<p>To get the same progress bars as the coursier CLI, one can do <pre><code>import coursier.cache.FileCache\nimport coursier.cache.loggers.RefreshLogger\nimport coursier.util.Artifact\nval logger = RefreshLogger.create()\nval cache = FileCache().withLogger(logger)\nval artifact = Artifact(\"https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.jar\")\nval file = logger.using(cache.file(artifact).run).unsafeRun()(cache.ec) // java.io.File\n// alternatively\nval file0 = logger.use(cache.file(artifact).run.unsafeRun()(cache.ec)) // java.io.File\n</code></pre></p> <p>Note the use of <code>logger.using</code> (<code>[T] (=&gt; coursier.util.Task[T]) =&gt; coursier.util.Task[T]</code>) or <code>logger.use</code> (<code>[T] (=&gt; T) =&gt; T</code>), that properly start and stop the logger before and after coursier cache use.</p>"},{"location":"api-cache/#parallel-downloads","title":"Parallel downloads","text":"<p>The coursier cache runs downloads in parallel (up to 6 in parallel by default). It does so by using a thread pool with at most 6 threads, that it runs downloads from. To pass an alternative thread pool to the coursier cache, call <code>withPool</code> on it, like <pre><code>import java.util.concurrent.ExecutorService\nval cache = FileCache().withPool(??? : ExecutorService)\n</code></pre></p> <p>Get the currently used pool with <pre><code>val cache = FileCache()\ncache.pool // ExecutorService\n</code></pre></p>"},{"location":"api-cache/#cache-location","title":"Cache location","text":"<p>Get the cache location with <pre><code>val cache = FileCache()\ncache.location // java.io.File\n</code></pre></p> <p>Override it with <pre><code>import java.io.File\nval cache = FileCache().withLocation(??? : File)\n</code></pre></p>"},{"location":"api-cache/#other-parameters","title":"Other parameters","text":"<p>Numerous aspects of the cache can be adjusted. Feel free to explore its fields and methods via your IDE or looking at the coursier source code.</p>"},{"location":"api-dependency/","title":"Dependency","text":"<p>One can specify input dependencies of a resolution via the <code>Dependency</code> class, like <pre><code>val module = Module(Organization(\"my-org\"), ModuleName(\"my-name\"), Map.empty)\nval versionConstraint = VersionConstraint(\"1.2.3\")\nDependency(module, versionConstraint)\n</code></pre></p> <p>In Scala 2.x, string interpolators allow to specify dependencies using the same syntax than on the CLI: <pre><code>dep\"my-org:my-name:1.2.3\"\n</code></pre></p>"},{"location":"api-dependency/#bill-of-material","title":"Bill Of Material","text":"<p>Bills Of Material, or BOMs, allow to:</p> <ul> <li>fill input dependencies' versions if these are empty</li> <li>override versions of transitive dependencies</li> </ul> <p>To pass a BOM to a dependency, you can call <code>addBom</code> on a <code>Dependency</code>: <pre><code>val module = Module(Organization(\"my-org\"), ModuleName(\"my-name\"), Map.empty)\nval versionConstraint = VersionConstraint(\"1.2.3\")\nval bomModule = Module(Organization(\"my-org\"), ModuleName(\"my-bom\"), Map.empty)\nval bomVersionConstraint = VersionConstraint(\"1.0.1\")\nDependency(module, versionConstraint)\n  .addBom(BomDependency(bomModule, bomVersionConstraint))\n</code></pre>  In Scala 2.x, on can use convenient string interpolators: <pre><code>dep\"my-org:my-name:1.2.3\"\n  .addBom(mod\"my-org:my-bom\", bomVersionConstraint)\n</code></pre> or <pre><code>dep\"my-org:my-name:1.2.3\"\n  .addBom(dep\"my-org:my-bom:1.0.1\".asBomDependency)\n</code></pre></p>"},{"location":"api-dependency/#gradle-module-variant","title":"Gradle Module Variant","text":""},{"location":"api-dependency/#enabling-gradle-module-support","title":"Enabling Gradle Module support","text":"<p>Gradle Module support needs to be enabled, either for individual Maven repositories, like <pre><code>Fetch()\n  .withRepositories(\n    Fetch().repositories.map {\n      case m: MavenRepository =&gt;\n        m.withCheckModule(true)\n      case other =&gt; other\n    }\n  )\n</code></pre> or for all repositories at once, like <pre><code>Fetch().withGradleModuleSupport(true)\n</code></pre></p>"},{"location":"api-dependency/#adding-attributes-to-dependencies","title":"Adding attributes to dependencies","text":"<p>Variant attributes can be specified once for all dependencies, with <pre><code>Fetch()\n</code></pre></p> <p>One can ask for specific Gradle Module variants of a dependency, like <pre><code>import coursier.core.VariantSelector.VariantMatcher\n\ndep\"my-org:my-name:1.2.3\".addVariantAttributes(\n  \"org.gradle.usage\"                   -&gt; VariantMatcher.Runtime,\n  \"org.jetbrains.kotlin.platform.type\" -&gt; VariantMatcher.Equals(\"js\"),\n  \"org.jetbrains.kotlin.js.compiler\"   -&gt; VariantMatcher.Equals(\"ir\"),\n  \"org.gradle.category\"                -&gt; VariantMatcher.Library\n)\n</code></pre></p> <p>Note that calling <code>Dependency#addVariantAttributes</code> discards any configuration details the dependency might have previously in its <code>variantSelector</code> field (see below).</p>"},{"location":"api-dependency/#gradle-module-variants-versus-maven-configuration","title":"Gradle Module Variants versus Maven Configuration","text":"<p>A <code>Dependency</code> instance can ask either for a Maven Configuration, or for Gradle Module variants. By default, <code>Dependency</code> instances ask for the empty configuration, which is interpreted internally as no configuration nor variants. During resolution, that empty configuration gets substituted by the default configuration pulled by the resolution (whose value is the <code>default(runtime)</code> configuration, meaning if direct dependencies have a configuration named <code>default</code>, it gets pulled - else, the configuration named <code>runtime</code> gets pulled).</p> <p>The dependency field handling both Gradle Module Variants and Maven Configurations is <code>Dependency#variantSelector</code>, whose type is <code>coursier.core.VariantSelector</code>: <pre><code>dep\"my-org:my-name:1.2.3\".variantSelector\n// res12: VariantSelector = ConfigurationBased(\n//   configuration = Configuration(value = \"\")\n// )\n</code></pre></p> <p><code>VariantSelector</code> is an ADT, and has 2 cases:</p> <ul> <li><code>VariantSelector.ConfigurationBased</code>, that corresponds to Maven Configurations</li> <li><code>VariantSelector.AttributesBased</code>, that corresponds to Gradle Module Variants</li> </ul>"},{"location":"api-dependency/#maven-configuration-fallback","title":"Maven Configuration fallback","text":"<p>coursier tries to download Gradle Module files if support for Gradle Modules is enabled. Such a support can be enabled</p> <p>If a repository doesn't have a Gradle Module file for such dependency, but has a POM file for it, coursier falls back to using Maven Configurations for this module. The configuration it falls back to is computed by the <code>VariantSelector.AttributesBased#equivalentConfiguration</code> method.</p> <p>As of writing this, it does the following:</p> <ul> <li>if the dependency has an <code>org.gradle.usage</code> attribute whose value is <code>java-api</code> or <code>kotlin-api</code>, it falls back to the <code>compile</code> Maven Configuration</li> <li>if the dependency has an <code>org.gradle.usage</code> attribute whose value is <code>java-runtime</code> or <code>kotlin-runtime</code>, it falls back to the <code>runtime</code> Maven Configuration</li> </ul> <p>If none of those conditions are met, during resolution, coursier falls back to the default configuration of the resolution (whose default value is <code>default(runtime)</code>).</p>"},{"location":"api-projects/","title":"coursier sub-projects","text":"<p>Some coursier core APIs have been moved to external repositories, so that these can be used in a standalone fashion.</p>"},{"location":"api-projects/#coursier-versions","title":"coursier-versions","text":"<p>The coursier-versions project publishes one main artifact, <code>io.get-coursier::versions</code>. It defines classes under <code>coursier.version</code>, most notably</p> <ul> <li><code>Version</code></li> <li><code>VersionInterval</code></li> <li><code>VersionConstraint</code></li> </ul> <p>These are now used by the core module of coursier and by its public API. Their use should be preferred to their deprecated equivalents under <code>coursier.core</code>.</p>"},{"location":"api-projects/#coursier-dependency","title":"coursier-dependency","text":"<p>The coursier-dependency project allows to define and parse dependencies. It can do so on the JVM, Scala.js, and Scala Native too (the latter not being supported by coursier itself). It mainly publishes the <code>io.get-coursier::dependency</code> module. It defines classes under the <code>dependency</code> package (right under root, so <code>_root_.dependency</code>).</p> <p>It's only used internally by coursier for now, but isn't part of its public API yet.</p> <p>The main user of this project for now should be Scala CLI, that uses it to parse dependencies in <code>//&gt; using dep</code> directives, among others.</p>"},{"location":"api/","title":"API","text":"<p>Coursier can be used as a Scala library. Its main dependency is <pre><code>io.get-coursier::coursier:2.1.25-M16-21-b126515f2-SNAPSHOT\n</code></pre></p> <p>coursier is built mainly for the JVM, although parts of it are also built for Scala.js, and an even more restrained subset of coursier is also built for Scala Native.</p> <p>The native CLI of coursier is based on the JVM, and is built using GraalVM native image. Most if not all coursier features ought to work fine from native images.</p> <p>The pages that follow document how to use coursier via its API.</p> <p>Most pages assume that the content of the <code>coursier</code> package has been imported, like <pre><code>import coursier._\n</code></pre></p>"},{"location":"cli-archive-cache/","title":"Archive cache","text":"<p>From the CLI, one can interact directly with the archive cache with <code>cs get --archive</code>. One can also adjust some archive cache parameters, that should apply to all applications using the coursier archive cache.</p> <p>Pass <code>--archive</code> to <code>cs get</code> to download and extract an archive: <pre><code>$ cs get --archive https://cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip\n~/.cache/coursier/arc/https/cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip\n</code></pre></p>"},{"location":"cli-archive-cache/#environment-variables","title":"Environment variables","text":""},{"location":"cli-archive-cache/#cache-location","title":"Cache location","text":"<p>Adjust the cache location with <code>COURSIER_ARCHIVE_CACHE</code>: <pre><code>$ export COURSIER_ARCHIVE_CACHE=\"/some/other/archive/location\"\n</code></pre></p>"},{"location":"cli-binaries/","title":"Binaries","text":"<p>CLI is available as native binaries, and as a JAR that needs an already installed JVM to run.</p> <p>Use binaries if one is available for your system (Linux and Mac on x86-64 and ARM64, Windows on x86-64)</p> <p>Else install a JVM on your own and use the JVM launcher (Windows on ARM64, *BSD, \u2026)</p> <p>Linux binaries are available for both x86-64 and ARM64. Extra shades of Linux binaries are also available for both CPU architectures: static binaries (no dynamic library dependencies, suitable for systems like Alpine), container binaries (<code>-H:-UseContainerSupport</code>, https://github.com/coursier/coursier/pull/2742)</p>"},{"location":"cli-cache/","title":"Cache","text":"<p>From the CLI, one can interact directly with the cache with <code>cs get</code>. One can also adjust some cache parameters, that should apply to all applications using coursier.</p>"},{"location":"cli-cache/#cs-get","title":"<code>cs get</code>","text":"<p>The <code>cs get</code> command of the coursier CLI allows to download files via the coursier cache: <pre><code>$ cs get https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.jar\n~/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.jar\n</code></pre></p> <p>For URLs whose content might change, pass <code>--changing</code>, to check for updates if the last check is older than the TTL: <pre><code>$ cs get https://repo1.maven.org/maven2/org/scala-lang/scala-library/maven-metadata.xml --changing\n~/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/maven-metadata.xml\n</code></pre></p>"},{"location":"cli-cache/#environment-variables","title":"Environment variables","text":""},{"location":"cli-cache/#cache-location","title":"Cache location","text":"<p>Adjust the cache location with <code>COURSIER_CACHE</code>: <pre><code>$ export COURSIER_CACHE=\"/some/other/location\"\n</code></pre></p>"},{"location":"cli-cache/#ttl","title":"TTL","text":"<p>Adjust the TTL with <code>COURSIER_TTL</code>: <pre><code>$ export COURSIER_TTL=\"1 hour\"\n</code></pre></p> <p>The value of <code>COURSIER_TTL</code> is parsed with <code>scala.concurrent.duration.Duration</code>.</p>"},{"location":"cli-ci-script/","title":"CLI script","text":"<p>https://github.com/coursier/ci-scripts</p>"},{"location":"cli-dependency/","title":"Dependency","text":""},{"location":"cli-dependency/#syntax","title":"Syntax","text":"<pre><code>org:name:version\n</code></pre>"},{"location":"cli-dependency/#bill-of-material","title":"Bill Of Material","text":"<p>One can pass a Bill-Of-Material, or BOM, via dependencies, like <pre><code>com.google.protobuf:protobuf-java-util,bom=com.google.protobuf%protobuf-bom%4.28.1\n</code></pre></p> <p>Note the use of <code>%</code> rather than <code>:</code> to separate the components of the BOM coordinates.</p>"},{"location":"cli-dependency/#gradle-module-variant","title":"Gradle Module Variant","text":"<p>One can add Gradle Module attributes to a dependency, so that it checks if a Gradle Module file exists for that dependency, and uses it to pick a \"variant\" of that dependency: <pre><code>org.jetbrains.kotlinx:kotlinx-html-js:0.11.0,variant.org.gradle.usage=kotlin-runtime,variant.org.jetbrains.kotlin.platform.type=js,variant.org.jetbrains.kotlin.js.compiler=ir,variant.org.gradle.category=library\n</code></pre></p> <p>If we split / indent that dependency for readability, we get <pre><code>org.jetbrains.kotlinx:kotlinx-html-js:0.11.0,\n  variant.org.gradle.usage=kotlin-runtime,\n  variant.org.jetbrains.kotlin.platform.type=js,\n  variant.org.jetbrains.kotlin.js.compiler=ir,\n  variant.org.gradle.category=library\n</code></pre></p> <p>Gradle Module attributes are key-value pairs. These are added as parameters to dependencies. <code>variant.</code> is added as prefix to the key of the attribute, and the parameter value is the attribute value.</p>"},{"location":"cli-report/","title":"JSON report","text":"<p>The <code>fetch</code> command of coursier CLI can generate a report, in JSON format, of the dependencies it fetched.</p> <p>This report can be used by other tools. Most notably, Bazel's rules_jvm_external relies on coursier to manage JVM dependencies. Before it, coursier's JSON reports were generated and used on the Twitter infrastructure via Pants.</p>"},{"location":"cli/","title":"CLI","text":"<p>Coursier can be used via its CLI. Its CLI is distributed as a native binary, and as a JAR that needs an already installed JVM to run.</p>"},{"location":"features-archive-cache/","title":"Coursier Archive Cache","text":"<p>The archive cache offers to unpack artifacts downloaded by the main coursier cache. It unpacks them in a predefined and stable location, so that things need to be unpacked only once, and can be re-used many times after that.</p> <p>For example, this archive ends up being unpacked in this location on Linux: <pre><code>~/.cache/coursier/arc/https/cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip/\n</code></pre></p> <p>Note the <code>arc</code> component in the path, where paths of the main coursier cache contain a <code>v1</code> instead.</p> <p>One can get such a path from the command-line, with: <pre><code>$ cs get --archive https://cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip\n~/.cache/coursier/arc/https/cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip\n\n$ ls \"$(cs get --archive https://cosmo.zip/pub/cosmocc/cosmocc-3.9.7.zip)\"\nLICENSE.gpl2\nLICENSE.gpl3\nLICENSE.lgpl2\nLICENSE.lgpl3\nREADME.md\naarch64-linux-cosmo\nbin\ninclude\nlib\nlibexec\nx86_64-linux-cosmo\n</code></pre></p> <p>This command downloads the artifact via the main coursier cache if needed, then unpacks it in the archive cache if needed. If the archive is already unpacked in the main archive cache, it doesn't check or try to download the artifact in the main coursier cache in the first place.</p>"},{"location":"features-archive-cache/#standalone-use","title":"Standalone use","text":"<p>While various features of coursier rely on the archive cache, it can be used in a standalone fashion via its API or via the CLI.</p>"},{"location":"features-archive-cache/#cache-location","title":"Cache location","text":"<p>The exact location of the archive cache is OS-dependent. Like for the main coursier cache, it relies on the directories-jvm library (more precisely, a slightly customized fork of it) to follow OS conventions and put the coursier cache at the most appropriate location for your OS.</p> OS Location Note Linux <code>~/.cache/coursier/arc/</code> XDG\u2026 macOS <code>~/Library/Caches/Coursier/arc/</code> Windows <code>C:\\Users\\username\\AppData\\Local\\Coursier\\Cache\\arc</code> Windows API\u2026"},{"location":"features-archive-cache/#archive-content-addressing","title":"Archive content addressing","text":"<p>One can get particular files in archives, by separating the archive URL and the path inside the archive with <code>!</code>, like <pre><code>$ cs get --archive 'https://ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb!data.tar.xz'\n~/.cache/coursier/arc/https/ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb/data.tar.xz\n</code></pre></p> <p>Note that if the URL passed to <code>cs get</code> contains <code>!</code>, it automatically assumes it deals with archives, so that <code>--archive</code> doesn't have to be passed: <pre><code>$ cs get 'https://ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb!'\n~/.cache/coursier/arc/https/ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb\n</code></pre></p>"},{"location":"features-archive-cache/#archives-in-archives","title":"Archives in archives","text":"<p>Using <code>!</code> like above multiple times, one can get files from archives contained themselves in archives: <pre><code>$ cs get --archive 'https://ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb!data.tar.xz!usr/bin/hello'\n~/.cache/coursier/arc/https/ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb/.data.tar.xz/usr/bin/hello\n\n$ cs get 'https://ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb!data.tar.xz!usr/share/doc/hello/changelog.gz!'\n~/.cache/coursier/arc/https/ftp.debian.org/debian/pool/main/h/hello/hello_2.10-3+b1_arm64.deb/data.tar.xz/usr/share/doc/hello/.changelog.gz/changelog\n</code></pre></p>"},{"location":"features-bom/","title":"Bill Of Material","text":"<p>Bills Of Material, or BOMs, allow to:</p> <ul> <li>fill input dependencies' versions if these are empty</li> <li>override versions of transitive dependencies</li> </ul> <p>See the dedicated API section and the dedicated CLI section.</p>"},{"location":"features-cache/","title":"Coursier Cache","text":"<p>This page is about the main, \"standard\", coursier cache. coursier has other kind of caches, such its archive cache, documented on its own page.</p> <p>The coursier cache aims at being quite generic. \"Cool URLs don't change\", and the coursier cache basically caches things using URLs as keys. For example, on Linux, this artifact ends up cached as <pre><code>~/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.pom\n</code></pre></p> <p>Using the coursier CLI, one can get this path with <pre><code>$ cs get https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.pom\n~/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.16/scala-library-2.13.16.pom\n</code></pre></p> <p>The exact location of the coursier cache on your system depends on your operating system (OS), see here.</p>"},{"location":"features-cache/#standalone-use","title":"Standalone use","text":"<p>The coursier cache can be used independently of dependency resolution. It can be used via its API or via the CLI.</p>"},{"location":"features-cache/#cache-location","title":"Cache location","text":"<p>The exact location of the coursier cache is OS-dependent. It relies on the directories-jvm library (more precisely, a slightly customized fork of it) to follow OS conventions and put the coursier cache at the most appropriate location for your OS.</p> OS Location Note Linux <code>~/.cache/coursier/v1/</code> XDG\u2026 macOS <code>~/Library/Caches/Coursier/v1/</code> Windows <code>C:\\Users\\username\\AppData\\Local\\Coursier\\Cache\\v1</code> Windows API\u2026"},{"location":"features-cache/#ttl","title":"TTL","text":"<p>The content pointed at by some URLs does change for some of them. That's the case for things such as version listings on Maven Central like this one, or so called \"snapshot\" artifacts like these.</p> <p>The coursier cache doesn't guess itself if a file at a URL can change or not. This has to be specified beforehand by cache user. For example, for dependency resolution, coursier marks version listings or snapshot artifacts as changing, while it doesn't for other resources.</p> <p>The coursier cache keeps on disk the last time it checked changing files for updates: <pre><code>$ cs get https://repo1.maven.org/maven2/org/scala-lang/scala-library/maven-metadata.xml --changing\n~/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/maven-metadata.xml\n$ ls -a \"$(dirname \"$(cs get https://repo1.maven.org/maven2/org/scala-lang/scala-library/maven-metadata.xml --changing)\")\"\n\u2026\n.maven-metadata.xml.checked\nmaven-metadata.xml\n\u2026\n</code></pre></p> <p>For a file named <code>thing</code>, the coursier cache writes an empty file named <code>.thing.checked</code>, whose last modified time is the last time it checked for updates of this file.</p>"},{"location":"features-docker/","title":"Docker","text":""},{"location":"features-gradle-modules/","title":"Gradle Modules support","text":"<p>coursier has some support for Gradle Modules. Gradle Modules allow resolutions to be more precise, fetching artifacts and dependencies more adapted to your environment. These are especially used in the Kotlin and Android ecosystems.</p> <p>Gradle Modules are <code>.module</code> files, like this one, that are pushed alongside <code>.pom</code> files to Maven repositories by some Gradle projects. They contain richer metadata that POM files, allowing users to specify different dependency sets and artifacts depending on the platform being used (JVM, Android, native, \u2026), in particular.</p> <p>Coursier is able to read and take into account <code>.module</code> files. Support for Gradle Modules needs to be explicitly enabled for now. See how that can be done via the API and via the CLI.</p>"},{"location":"features-gradle-modules/#attributes-matching","title":"Attributes matching","text":"<p>When fetching dependencies with Gradle Module support enabled, you should pass variant attributes to coursier. These attributes specify details about the environment you want to fetch dependencies for.</p> <p>For example, from the command-line, resolving some dependencies with Gradle Module support enabled can fail at first if we don't pass variant attributes: <pre><code>$ cs resolve org.jetbrains.kotlinx:kotlinx-html-js:0.11.0 --enable-modules\nResolution error: Error downloading org.jetbrains.kotlin:kotlin-stdlib:1.9.22\n  Found too many variants in org.jetbrains.kotlin:kotlin-stdlib:1.9.22 for { org.gradle.category=library, org.gradle.usage=runtime }:\njsRuntimeElements: {\n  org.gradle.category: library\n  org.gradle.jvm.environment: non-jvm\n  org.gradle.usage: kotlin-runtime\n  org.jetbrains.kotlin.js.compiler: ir\n  org.jetbrains.kotlin.platform.type: js\n  $relocated: true\n}\njsV1RuntimeElements: {\n  org.gradle.category: library\n  org.gradle.jvm.environment: non-jvm\n  org.gradle.usage: kotlin-runtime\n  org.jetbrains.kotlin.js.compiler: legacy\n  org.jetbrains.kotlin.platform.type: js\n  $relocated: true\n}\njvmRuntimeElements: {\n  org.gradle.category: library\n  org.gradle.jvm.environment: standard-jvm\n  org.gradle.libraryelements: jar\n  org.gradle.usage: java-runtime\n  org.jetbrains.kotlin.platform.type: jvm\n}\nwasmJsRuntimeElements: {\n  org.gradle.category: library\n  org.gradle.jvm.environment: non-jvm\n  org.gradle.usage: kotlin-runtime\n  org.jetbrains.kotlin.platform.type: wasm\n  org.jetbrains.kotlin.wasm.target: js\n  $relocated: true\n}\nwasmWasiRuntimeElements: {\n  org.gradle.category: library\n  org.gradle.jvm.environment: non-jvm\n  org.gradle.usage: kotlin-runtime\n  org.jetbrains.kotlin.platform.type: wasm\n  org.jetbrains.kotlin.wasm.target: wasi\n  $relocated: true\n}\n</code></pre></p> <p>The error implies that coursier wasn't able to pick a variant among the ones it found, that are displayed. In order to address that, we must pass variant attributes, that are going to be matched against those of the variants proposed by each module.</p> <p>Passing variant attributes resolves that issue: <pre><code>$ cs resolve org.jetbrains.kotlinx:kotlinx-html-js:0.11.0 --enable-modules --variant org.gradle.category=library --variant org.gradle.jvm.environment=standard-jvm\norg.jetbrains:annotations:13.0:default\norg.jetbrains.kotlin:kotlin-dom-api-compat:1.9.22:{ org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=runtime }\norg.jetbrains.kotlin:kotlin-stdlib:1.9.22:{ org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=runtime }\norg.jetbrains.kotlinx:kotlinx-html-js:0.11.0:{ org.gradle.category=library, org.gradle.jvm.environment=standard-jvm, org.gradle.usage=runtime }\n</code></pre></p> <p>In order to pick the variant of a module, coursier looks at the variant attributes it is passed as input (in the command above, <code>org.gradle.category</code> with value <code>library</code>, and <code>org.gradle.jvm.environment</code> with value <code>standard-jvm</code>). coursier iterates on each of those input attributes, and a variant is retained if and only if:</p> <ul> <li>it either doesn't have that attribute, or</li> <li>it has that attribute, and its value is the same as the one in the user input (matching of the values is actually more refined, see below)</li> </ul> <p>For a variant to be retained, either of those conditions have to be met for all input attributes.</p> <p>If only a single variant remains after that selection, it is picked. If none remain, resolution fails. If several variants remain, coursier keeps the one(s) that match(es) the most input values (second condition above met for the most input attributes); if that still corresponds to several variants, then resolution fails.</p>"},{"location":"features-gradle-modules/#attribute-value-comparisons","title":"Attribute value comparisons","text":"<p>Most of the time, values of input versus incoming module attributes are directly compared, and match if they're equal. For some attributes, the matching can be more loose:</p> <ul> <li>for <code>org.gradle.usage</code>, if users pass <code>api</code> as a value, then things like <code>java-api</code> or <code>kotlin-api</code> also match - more generally, anything ending in <code>-api</code> is accepted, alongside just <code>api</code></li> <li>still for <code>org.gradle.usage</code>, if users pass <code>runtime</code> as a value, then things like <code>java-runtime</code> or <code>kotlin-runtime</code> also match - more generally, anything ending in <code>-runtime</code> is accepted, alongside just <code>runtime</code></li> <li>for <code>org.gradle.jvm.version</code>, users can pass a JVM major version, like <code>8</code> or <code>17</code>, and any version higher or equal to that is accepted</li> </ul> <p>Note that this list may evolve in the future, as Gradle Module support in coursier gets refined.</p>"},{"location":"features-gradle-modules/#variant-attributes-as-a-substitute-to-maven-configuration","title":"Variant attributes as a substitute to Maven configuration","text":"<p>This section describes the interplay between Maven configurations (<code>compile</code>, <code>runtime</code>, \u2026) and variant attributes. This point is important to understand if you're obtaining surprising results in resolutions involving both modules having <code>.module</code> files and modules having only POM files.</p> <p>During resolution, variant attributes play the same role as Maven configurations: they help pick the exact dependency set and artifacts of a given dependency. Internally, a dependency has either variant attributes or a Maven configuration, but not both.</p> <p>Note that the variant attribute set or the Maven configuration can be empty, and these are assumed to be equivalent - and empty - in that case. By default, dependencies created via the API or on the command-line have an empty configuration.</p> <p>When a <code>.module</code> file is available for a dependency, 3 cases can happen:</p> <ul> <li>the dependency has an empty configuration or an empty variant attribute set. Then the default attribute   set is used. It's the one passed via <code>--variant</code> on the command-line or with <code>Resolve.withDefaultVariantAttributes</code>   or <code>Fetch.withDefaultVariantAttributes</code> via the API</li> <li>the dependency has variant attributes. In that case, these are used.</li> <li>the dependency has a configuration. In that case, an equivalent attribute set is computed as below, and added   to the default attribute set (the entries of former taking precedence over those of the latter)</li> </ul> <p>When no module file is available, and a <code>.pom</code> file is used, 3 cases can happen:</p> <ul> <li>the dependency has an empty configuration or an empty variant attribute set. Then the default configuration   is used. It can be passed on the command-line via <code>--configuration</code> or <code>-c</code>, like <code>-c compile</code>, and with   <code>Resolve.withDefaultConfiguration</code> or <code>Fetch.withDefaultConfiguration</code> via the API. It defaults   to <code>default(runtime)</code>, which is equivalent to <code>runtime</code> in practice.</li> <li>the dependency has variant attributes. In that case, an equivalent configuration is computed from the attributes   as below, or the default configuration is used if no configuration can be   computed from variant attributes.</li> <li>the dependency has a configuration. In that case, its configuration is used.</li> </ul>"},{"location":"features-gradle-modules/#fallback-from-maven-configuration","title":"Fallback from Maven configuration","text":"<p>When all we have is a Maven configuration when variant attributes are needed, the following variant attributes are used:</p> <ul> <li><code>compile</code> configuration<ul> <li><code>org.gradle.category=library</code></li> <li><code>org.gradle.usage=api</code></li> </ul> </li> <li> <p><code>runtime</code> or <code>default</code> configuration</p> <ul> <li><code>org.gradle.category=library</code></li> <li><code>org.gradle.usage=runtime</code></li> </ul> </li> <li> <p>other configurations: no variant attributes</p> </li> </ul> <p>Note that the default attributes (passed on the command-line via <code>--variant</code>) are added to those, but do not take precedence over them.</p>"},{"location":"features-gradle-modules/#fallback-to-maven-configuration","title":"Fallback to Maven configuration","text":"<p>When all we have is variant attributes when a Maven configuration is needed, the following configuration is used:</p> <ul> <li>if <code>org.gradle.usage</code> is in the attribute set, and its value is <code>api</code> or ends with <code>-api</code>, then the   <code>compile</code> configuration is used</li> <li>if <code>org.gradle.usage</code> is in the attribute set, and its value is <code>runtime</code> or ends with <code>-runtime</code>, then the   <code>runtime</code> configuration is used</li> <li>in all other cases, no configuration is deduced from the variant attributes, and the default configuration   ends up being used</li> </ul>"},{"location":"features-gradle-modules/#consistency-between-maven-configuration-and-variant-attributes","title":"Consistency between Maven configuration and variant attributes","text":"<p>When passing default attributes and a default configuration to coursier, you should make sure that these are consistent. That is, the fallback configuration of the default attributes should correspond to the configuration, and the fallback attributes of the configuration ought to be contained in the default attributes.</p> <p>That helps get a consistent set of dependencies (compile time dependencies, or runtime dependencies), rather than a mix of both depending on whether dependencies have <code>.module</code> files available or not.</p> <p>In practice, that means that if the <code>org.gradle.usage</code> attribute is <code>api</code>, you should ask for <code>compile</code> as the default configuration; if the <code>org.gradle.usage</code> attribute is <code>runtime</code>, you should ask for <code>runtime</code> as the default configuration (which is the default for the default configuration).</p>"},{"location":"features-gradle-modules/#transitiveness-of-variant-attributes","title":"Transitiveness of variant attributes","text":"<p>Note that the user-specified input attributes above aren't the only input attributes taken into account. When a variant is picked during resolution, all its attributes are passed to its dependencies, which helps disambiguate variants of these dependencies. The user-specified attributes are part of those, because of the way these are passed around during resolution (see above), unless users manually specified variants for specific root dependencies, using a syntax like this for dependencies <pre><code>org.jetbrains.kotlinx:kotlinx-html-js:0.11.0,variant.org.gradle.usage=kotlin-runtime,variant.org.jetbrains.kotlin.platform.type=js,variant.org.jetbrains.kotlin.js.compiler=ir,variant.org.gradle.category=library\n</code></pre></p> <p>Note that you shouldn't use this syntax, unless you really know what you are doing. If its attributes aren't part of the default attributes, and some transitive dependencies have only POM files, the interplay between variant attributes and Maven configuration may modify the resolution result in unexpected way, with the variant being unexpectedly lost during resolution sometimes.</p>"},{"location":"features-jvm/","title":"JVM","text":"<p>Coursier can act as a JVM manager like SDKMAN or asdf.</p> <p>One notable feature of it is that it can give you the Java home of a JDK distribution without actually \"installing\" it or \"setting it up\" on your system, but only relying on the various coursier caches. That allows to manage several JDKs in parallel, with users using a main default JDK, but using another one in a particular shell session, while apps can use some other JDKs.</p> <p>The JVM management features of coursier rely on its JVM index. This index is updated on a regular basis, and list JDKs from various vendors, such as Temurin, GraalVM, Zulu, Liberica, etc. See here for a more up-to-date list.</p> <p>The coursier JVM index is published both on GitHub and on Maven Central. Both the API and the CLI of coursier default to the index on GitHub.</p> <p>In more detail, when asked for a JVM, coursier first downloads a JVM index. It then look for an entry in it adapted to the current OS and CPU architecture, and satisfying the user's request. It then uses the archive cache of coursier to get an extracted version of that archive on disk. The archive cache itself downloads the archive if needed with the standard coursier cache, and extracts it under its own cache directory.</p> <p>So the JVMs live under the archive cache directory.</p>"},{"location":"features/","title":"Coursier features","text":"<p>These pages are deep dives into various features of coursier. They sometimes link to sections of the API or CLI documentations for more details.</p>"},{"location":"java-api/","title":"coursier Java API","text":"<p>coursier can be used from pure Java projects, but also from Scala projects, via its Java API.</p> <p>The coursier Java API is currently handled from an external repository, although it might be moved to the main repository at some point.</p> <p>It is published as <code>io.get-coursier:interface</code>, and aims at minimizing binary compatibility breakages - it basically never broke binary compatibility since its very first release (but for one borked release).</p> <p>It only depends on <code>slf4j-api</code>. Most notably, it doesn't depend on the Scala standard library or any other Scala project. coursier being written in Scala, this is achieved by shading / proguarding all coursier dependencies. This results in a slightly heavy JAR, that embeds under the <code>coursierapi.shaded</code> most coursier dependencies. Note that users shouldn't tap directly into the APIs under <code>coursierapi.shaded</code> - these are considered private, and no compatibility guarantees apply to those.</p>"},{"location":"reference-repositories/","title":"Repositories","text":"<p>Coursier accepts repositories as strings in a number of places, most notably on its command-line and via its repository parser.</p> <p>On the command-line, most commands accepting dependencies accept extra repositories via <code>-r</code> or <code>--repository</code>: <pre><code>$ cs resolve -r google androidx.test.ext:junit:1.2.1\n</code></pre></p> <p>Via its API, you can use <code>coursier.parse.RepositoryParser</code> to get a <code>coursier.core.Repository</code> out of a string: <pre><code>import coursier.parser.RepositoryParser\nRepositoryParser.repository(\"google\") == Right(coursier.Repositories.google)\n</code></pre></p>"},{"location":"reference-repositories/#accepted-values","title":"Accepted values","text":"<p>Several kind of values are accepted as repositories:</p> <ul> <li>a number of pre-defined values for the most commonly used repositories</li> <li>URLs, that are mapped to a Maven repository with the URL as root</li> <li>URLs prefixed with <code>ivy:</code>, optionally followed by \"Ivy patterns\", are mapped to Ivy repositories</li> </ul>"},{"location":"reference-repositories/#short-syntax","title":"Short syntax","text":"<p>A number of predefined values are accepted:</p> short syntax long form details <code>central</code> <code>https://repo1.maven.org/maven2</code> Maven Central, the most commonly used Maven repository <code>ivy2Local</code> <code>file://${ivy.home-${user.home}/.ivy2}/local/[defaultPattern]</code> The local Ivy2 repository, where Mill, Scala CLI, or sbt, publish to when asked to publish locally <code>m2Local</code> <code>file://${user.home}/.m2/repository</code> The local Maven repository, whose use is NOT recommended from coursier, see below <code>sonatype:$name</code> <code>https://oss.sonatype.org/content/repositories/$name</code> Sonatype, most commonly used service to push artifacts to Maven Central. Example: <code>sonatype:snapshots</code> <code>sonatype-s01:$name</code> <code>https://s01.oss.sonatype.org/content/repositories/$name</code> New Sonatype servers. Example: <code>sonatype-s01:snapshots</code> <code>scala-integration</code> or <code>scala-nightlies</code> <code>https://scala-ci.typesafe.com/artifactory/scala-integration</code> Repository where Scala 2 nighly artifacts are pushed <code>jitpack</code> <code>https://jitpack.io</code> Service that automatically builds artifacts from a GitHub repository <code>clojars</code> <code>https://repo.clojars.org</code> Repository commonly used in the Clojure ecosystem <code>google</code> <code>https://maven.google.com</code> Google-managed repository, that distributes some Android artifacts in particular <code>gcs</code> <code>https://maven-central.storage-download.googleapis.com/maven2</code> Google-managed mirror of Maven Central <code>gcs-eu</code> <code>https://maven-central-eu.storage-download.googleapis.com/maven2</code> Google-managed mirror of Maven Central, should be Europe-based <code>gcs-asia</code> <code>https://maven-central-asia.storage-download.googleapis.com/maven2</code> Google-managed mirror of Maven Central, should be Asia-based <p>A number of less commonly-used short syntaxes are also accepted. See the parser sources (currently living here) for a more comprehensive list.</p> <p>About <code>m2Local</code>, it is recommended not to use it from coursier. Maven uses it as a cache, but sometimes doesn't download all artifacts of a given module version. As a consequence, if coursier picks this repository during resolution for a module version, the artifacts that have not been downloaded by Maven will be missing from coursier. There's currently no workaround for this, apart from not using <code>m2Local</code> from coursier. Only use this repository if you are aware of that caveat.</p>"},{"location":"reference-repositories/#maven-repositories","title":"Maven repositories","text":"<p>Passing a URL is interpreted as a Maven repository with the URL as root, like: <pre><code>https://oss.sonatype.org/content/repositories/snapshots\n</code></pre></p> <p>Such a repository is expected to have artifacts looking like <pre><code>https://oss.sonatype.org/content/repositories/snapshots/the/organization/the-name/X.Y.Z/the-name-X.Y.Z.pom\nhttps://oss.sonatype.org/content/repositories/snapshots/the/organization/the-name/X.Y.Z/the-name-X.Y.Z.jar\n</code></pre></p> <p>(Note that this particular example also has a shorter syntax, <code>sonatype:snapshots</code>, see above.)</p> <p>Note that the <code>file</code> scheme is accepted, so that local directories can be used as Maven repositories too: <pre><code>file:///Users/alex/test-repo\n</code></pre></p> <p>In that case, artifacts such as those are expected: <pre><code>/Users/alex/test-repo/the/organization/the-name/X.Y.Z/the-name-X.Y.Z.pom\n/Users/alex/test-repo/the/organization/the-name/X.Y.Z/the-name-X.Y.Z.jar\n</code></pre></p>"},{"location":"reference-repositories/#ivy-repositories","title":"Ivy repositories","text":"<p>These consist in a URL, prefixed with <code>ivy:</code>, and optionally followed by an \"Ivy pattern\": <pre><code>ivy:https://repo.typesafe.com/typesafe/ivy-releases/[organisation]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]\n</code></pre></p> <p>Such a repository expects artifacts looking like <pre><code>https://repo.typesafe.com/typesafe/ivy-releases/the-organisation/the-name/X.Y.Z/ivys/ivy.xml\nhttps://repo.typesafe.com/typesafe/ivy-releases/the-organisation/the-name/X.Y.Z/ivys/the-name.jar\n</code></pre></p> <p><code>file</code> URLs are also accepted, and Java properties can also be used: <pre><code>file://${ivy.home-${user.home}/.ivy2}/local/[defaultPattern]\n</code></pre></p> <p>If the <code>ivy.home</code> Java property is set, its value is replaces the whole of <code>${ivy.home-${user.home}/.ivy2}</code>. Else, the value after <code>-</code> is used. If <code>user.home</code> is <code>/Users/alex</code>, we get <code>/Users/alex/.ivy2</code>. If a property is unset, and has no fallback, parsing fails.</p> <p><code>[defaultPattern]</code> is a shorter syntax for a commonly used Ivy pattern. It's used by the Ivy2 local repository, that Mill, Scala CLI, or sbt use.</p> <p>(Note that that particular example has a shorter syntax: <code>ivy2Local</code>, see above.)</p>"}]}